//////////////////////////////////////////////////////////////////////////////
version="version schreyforncalg.lib 1.0.0.0 Feb_2024 "; // $Id$
category="Noncommutative";
info="
LIBRARY: schreyforncalg.lib     Schreyer's algorithm for modules over the exterior algebra
AUTHORS:   Ramesh, L.,     ramesh@mathematik.uni-kl.de


OVERVIEW:
--

PROCEDURES:
--
";


LIB "nctools.lib"; // for ncalg
LIB "matrix.lib"; // for submat

///////////////////////////////////////////////////////////////////////////////

proc leadmonomial(def s) 
"USAGE:   leadmonomial(s); s a vector or a polynomial
RETURN:   poly
PURPOSE:  to compute lcm of lead terms of two vectors over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example leadmonomial; shows examples
SEE ALSO: leadterm
"{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=leadmonom(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=leadmonom(s);
   }
  return(m);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  vector v = [x2+y,0,z];
  leadmonomial(v);
}

///////////////////////////////////////////////////////////////////////////////

proc leadterm(def s)
"USAGE:   leadterm(s); s a vector or a polynomial
RETURN:   poly
PURPOSE:  to compute lcm of lead terms of two vectors over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example leadterm; shows examples
SEE ALSO: leadmonomial
"{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=lead(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=lead(s);
   }
  return(m);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  vector v = [x2+y,0,z];
  leadterm(v);
}

///////////////////////////////////////////////////////////////////////////////

// This procedure was implemented as there is no lcm over non-commutative rings

//assumes v,w are terms that are either linear in each variable, or quadratic in one variable
proc lcm_(poly v, poly w)
"USAGE:   lcm_(v,w); v and w in a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
RETURN:   poly
PURPOSE:  to compute lcm of lead terms of two vectors over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example lcm_; shows examples
SEE ALSO: leadmonomial, leadterm
"{
    string strv = string(v);
    string strw = string(w);
    int sizev = size(strv);
    int sizew = size(strw);
    int n = nvars(basering);
    int i;
    intvec expv, expw;
    poly ans = 1;
    if (strv[sizev] == "2" && strw[sizew] == "2"){
      ans = 0;
      return(ans); // not sure about type
    }
    else{
      if (strv[sizev] != "2" && strw[sizew] != "2"){
        expv = leadexp(v);
        expw = leadexp(w);
        for (i=1; i<=n; i++){
          if (expv[i]==1 || expw[i]==1){
            ans = ans*var(i);
          }
        }
        return(ans);
      }
      else {
        if (strv[sizev] == "2"){
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expv[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expw[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        else{
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expw[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expv[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        return(ans);
      }
    }
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////


/* This procedure computes the schreyers syzygy algorithm over a non-commutative ring 
where var(i)*var(j) = -var(j)*var(i), and 
assumes that the generators of the given matrix are lifted from the exterior algebra to the non-commutative algebra.*/


proc schreyers_syz_(module m)
"USAGE:   Gweights(r); r a ring or a square matrix
RETURN:   intvec
PURPOSE: compute an appropriate weight int vector for a G-algebra, i.e., such that
\foral\;i<j\;\;lm_w(d_{ij}) <_w x_i x_j.
@*       the polynomials d_{ij} are taken from r itself, if it is of the type ring
@*       or defined by the given square polynomial matrix
THEORY:   @code{Gweights} returns an integer vector, whose weighting should be used to redefine the G-algebra in order
to get the same non-commutative structure w.r.t. a weighted ordering. If the input is a matrix and the output is the zero
vector then there is not a G-algebra structure associated to these relations with respect to the given variables.
@*Another possibility is to use @code{weightedRing} to obtain directly a G-algebra with the new appropriate (weighted) ordering.
EXAMPLE: example Gweights; shows examples
SEE ALSO: weightedRing
"{
  module lead_mod = lead_syz_(m);
  module ans;
  vector s;
  int i;
  for (i=1;i<=size(lead_mod); i++){
    s = lift_tree_(lead_mod[i], m);
    ans[size(ans)+1] = s;
  }
  return(ans);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

//not user-callable

proc lead_syz_(module m){
  int r = size(m);
  int n = nvars(basering);
  module M = std(freemodule(r));
  vector pi, pj, t, s;
  poly Li, Lj, mji;
  int i, j, k, expi, expj;
  module lead_mod; //this is what we will return

  for(i=1; i<=r; i++){
    pi = m[i];
    for(j=i+1; j<=r; j++){
      pj = m[j];
      expi = leadexp(pi)[n+1];
      expj = leadexp(pj)[n+1];
      if(expi == expj){
        Li = leadmonomial(pi);
        Lj = leadmonomial(pj);
        mji = lcm_(Lj,Li)/leadterm(pi);
        t = mji*M[i];
        for (k=1;k<=size(lead_mod);k++){
          if (NF(t, lead_mod[k])==0){
            t = 0;
            break;
          }
          else{
            if(NF(lead_mod[k], t)==0){
              lead_mod = delete(lead_mod, k);
              k = k-1;
            }
          }
        }
        if(t != 0){
          lead_mod[size(lead_mod)+1] = t;
        }
      }
    }
  }
  return(lead_mod);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

proc lift_tree_(vector s, module M){
  vector g = phi_(s, M);
  vector T = remove_LOT_(g, M);
  vector L;
  vector ans = s; 
  int i;
  poly m;

  ideal im, iF_, imif, iL;

  while (g != 0){
    L = lead(g);
    for(i=1; i<=size(M); i++){
      if(NF(L, leadmonom(M[i]))==0){
        m = leadmonomial(L)/leadterm(M[i]); 
        
        //check sign: 
        im = m; iF_ = leadterm(M[i]); imif = im*iF_; iL = leadterm(L);
        if (imif[1] != iL[1]){
          m = -m;
        } 

        if (greater_than_(s, m*gen(i), M)){
          ans = ans - lift_subtree_(m*gen(i),M);
          break;
        }
      }
    }
    g = g - L;
  }
  return(ans);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

proc lift_subtree_(vector s, module M){
  vector g = phi_(s, M);
  g = g - lead(g);
  vector T = remove_LOT_(g, M);
  vector ans = s;
  poly m;
  int i;
  vector L;

  ideal im, iF_, imif, iL;

  while (g != 0){
    L = lead(g);
    for(i=1; i<=size(M); i++){
      if(NF(L, leadmonom(M[i]))==0){
        m = leadmonomial(L)/leadmonomial(M[i]); //TODO check sign!

        //check sign: 
        im = m; iF_ = leadterm(M[i]); imif = im*iF_; iL =leadterm(L);
        if (imif[1] != iL[1]){
          m = -m;
        } 

        ans = ans - lift_subtree_(m*gen(i),M);
        break;
      }
    }
    g = g - L;
  }
  return(ans);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

//used in lift_tree_ and lift_subtree_
//computes the image of an element of lead_syz(m) in m

proc phi_(vector s, module m){
  int n = nvars(basering);
  int i = leadexp(s)[n+1];
  //s is a terms
  poly t = leadterm(s);
  return(t*m[i]);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

//removes lower order terms from a vector with respect to a module in std form

//used in lift_tree_ and lift_subtree_
proc remove_LOT_(vector g, module m){
  vector L;
  int i;
  vector LOT;
  while(g != 0){
    for(i=1; i<=size(m); i++){
      L = lead(g);
      if(NF(L, leadmonom(m[i])) == 0){
        LOT = LOT+L;
        break;
      }
    }
    g = g - L;
  }
  return(LOT);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

// This procedure is implemented as a substitute for the schreyer ordering check in lift_tree

proc greater_than_(vector s, vector v, module M){
  int n = nvars(basering);
  int i = leadexp(s)[n+1];
  int j = leadexp(v)[n+1];
  poly mi = leadmonomial(s);
  poly mj = leadmonomial(v);
  if (lead(mi*M[i]) > lead(mj*M[j])){
    return(1);
  }
  else{
    if(lead(mi*M[i]) == lead(mj*M[j]) && i>j){
      return(1);
    }
    return(0);
  }
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
//NOTE: in the following code, there is no quotient ring computation. 
//
//now for exterior algebra 
//lifting the module from the quotient ring to the ncalg
proc add_ideal_gens_(module m){
  int n = nvars(basering);
  int i,j;
  for (i = 1; i<= n; i++){
    for (j = 1; j<= rank(m); j++){
      m[size(m)+1] = var(i)^2 * gen(j);
    }
  }
  return(m);
}


proc ext_elimination_(module m, module syz_mod){
  //note m is NOT lifted.
  int r = size(m);
  int n = nvars(basering);
  module ans_mod;
  matrix needed_mat = submat(matrix(syz_mod), 1..r, 1..size(syz_mod));
  ans_mod = module(needed_mat);
  int i,j,k;

  for(i=1;i<=size(ans_mod);i++){
    for(j=1;j<=nrows(matrix(ans_mod[i]));j++){
      for(k=1;k<=n;k++){
        if ((NF(ans_mod[i][j], var(k)^2) == 0) && ans_mod[i][j] != 0){
          ans_mod[i] = ans_mod[i] - ans_mod[i][j]*gen(j);
          break;
        }
      }
    }
    if(ans_mod[i] == 0){
        ans_mod = delete(ans_mod, i);
        i = i-1;
    }
  }
  return(ans_mod);
}
example
{
  //TODO
}

///////////////////////////////////////////////////////////////////////////////

//THIS IS THE MAIN USER CALLABLE PROCEDURE
proc total_syz_alg(module m)
"USAGE:   total_syz_alg(m); m a module over a noncommutative ring where var(i)*var(j) = -var(j)*var(i)
and the generators of m are 0 modulo var(i)^2 for all i.
RETURN:   module
PURPOSE:  computes the syzygy module of a module m over the exterior algebra. 
THEORY:   TODO
SEE ALSO: -
"{
  module lift_m = add_ideal_gens_(m);
  module syz_mod = schreyers_syz_(lift_m);
  module ans_mod = ext_elimination_(m,syz_mod);
  return(ans_mod);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = (0,q),(a,b,c,d),lp;
  int N = nvars(basering);
  ring @R = create_ring(ring_list(basering)[1], ringlist(basering)[2], "("+ordstr(basering)+")", "no_minpoly");
  matrix @E = UpOneMatrix(N);
  @E = -1*(@E);
  def @@RR = nc_algebra(@E,0); setring @@RR;
  vector f1 = [x,y,0,z,0,0];
  vector f2 = [0,x,y,0,z,0];
  vector f3 = [0,0,0,x,y,z];
  vector f4 = [0,0,xy,0,xz,0];
  vector f5 = [0,0,0,0,xy,xz];
  vector f6 = [0,0,0,0,0,xyz];
  module m = f1,f2,f3,f4,f5,f6;
  total_syz_alg(m);
}
