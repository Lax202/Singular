//in this file we remove the sort function. It takes more time to sort than to check schreyer order with a list. 
//////////////////////////////////////////////////////////////////////////////
version="version sresforextalg.lib 1.0.0.0 Feb_2024 "; // $Id$
category="Noncommutative";
info="
LIBRARY: sresforextalg.lib     Schreyer's algorithm for modules over the exterior algebra
AUTHORS:   Ramesh, L.,     ramesh@mathematik.uni-kl.de
           Gnawali, S.,    


OVERVIEW:
--

PROCEDURES:
--
";

static proc mod_init()
{
LIB "nctools.lib"; // for ncalg
LIB "matrix.lib"; // for submat
LIB "classify.lib"; // for swap 
LIB "tst.lib"; tst_init(); tst_ignore("// ** loaded "); tst_ignore("// ** _ is no standard basis");
}

///////////////////////////////////////////////////////////////////////////////

proc leadmonomial_ext(def s) 
"USAGE:   leadmonomial_ext(s); s a vector or a polynomial
RETURN:   poly
PURPOSE:  to compute lcm of lead terms of two vectors over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example leadmonomial_ext; shows examples
SEE ALSO: leadterm
"
{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=leadmonom(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=leadmonom(s);
   }
  return(m);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  vector v = [x2+y,0,z];
  leadmonomial_ext(v);
}

///////////////////////////////////////////////////////////////////////////////

proc leadterm(def s)
"USAGE:   leadterm(s); s a vector or a polynomial
RETURN:   poly
PURPOSE:  to compute lcm of lead terms of two vectors over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example leadterm; shows examples
SEE ALSO: leadmonomial_ext
"
{
  int e;
  poly m;

  if(typeof(s) == "vector"){
    e=leadexp(s)[nvars(basering)+1];
    m=lead(s)[e,1];
  }
  if(typeof(s) == "poly"){
    m=lead(s);
   }
  return(m);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  vector v = [x2+y,0,z];
  leadterm(v);
}

///////////////////////////////////////////////////////////////////////////////

// This procedure was implemented as there is no lcm over non-commutative rings

//assumes v,w are terms that are either linear in each variable, or quadratic in one variable
proc lcm_(poly v, poly w)
"USAGE:   lcm_(v,w); v and w in a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
RETURN:   poly
PURPOSE:  to return the lead monomial and coefficient (not component) of a vector over a non-commutative ring where var(i)*var(j) = -var(j)*var(i)
THEORY:   -
EXAMPLE:  example lcm_; shows examples
SEE ALSO: leadmonomial_ext, leadterm
"
{
    string strv = string(v);
    string strw = string(w);
    int sizev = size(strv);
    int sizew = size(strw);
    int n = nvars(basering);
    int i;
    intvec expv, expw;
    poly ans = 1;
    if (strv[sizev] == "2" && strw[sizew] == "2"){
      ans = 0;
      return(ans); // not sure about type
    }
    else{
      if (strv[sizev] != "2" && strw[sizew] != "2"){
        expv = leadexp(v);
        expw = leadexp(w);
        for (i=1; i<=n; i++){
          if (expv[i]==1 || expw[i]==1){
            ans = ans*var(i);
          }
        }
        return(ans);
      }
      else {
        if (strv[sizev] == "2"){
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expv[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expw[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        else{
          expw = leadexp(w);
          expv = leadexp(v);
          for (i=1; i<=n; i++){
            if (expw[i] == 2){
              ans = ans*(var(i))^2;
            }
            else{
              if (expv[i] == 1){
                ans = ans*var(i);
              }
            }
          }
        }
        return(ans);
      }
    }
}


///////////////////////////////////////////////////////////////////////////////


/* This procedure computes the schreyers syzygy algorithm over a non-commutative ring 
where var(i)*var(j) = -var(j)*var(i), and 
assumes that the generators of the given matrix are lifted from the exterior algebra to the non-commutative algebra.*/


proc schreyers_syz_(module m)
"USAGE:   schreyers_syz_(m);
RETURN:   module
PURPOSE:  returns the syzygy module of m using the schreyer algorithm, where m is a module 
over a non-commutative ring where x_i*x_j = -x_j*x_i
THEORY:   
SEE ALSO: 
"
{
  module lead_mod = lead_syz_(m);
  module ans;
  vector s;
  int i;
  for (i=1;i<=size(lead_mod); i++){
    s = lift_tree_(lead_mod[i], m);
    ans[size(ans)+1] = s;
  }
  return(ans);
}

///////////////////////////////////////////////////////////////////////////////

//not user-callable

proc lead_syz_(module m){
  int r = size(m);
  int n = nvars(basering);
  module M = std(freemodule(r));
  vector pi, pj, t, s;
  poly Li, Lj, mji;
  int i, j, k, expi, expj;
  module lead_mod; //this is what we will return

  for(i=2; i<=r; i++){
    pi = m[i];
    for(j=1; j<i; j++){
      pj = m[j];
      expi = leadexp(pi)[n+1];
      expj = leadexp(pj)[n+1];
      if(expi == expj){
        Li = leadmonomial_ext(pi);
        Lj = leadmonomial_ext(pj);
        mji = lcm_(Lj,Li)/leadterm(pi);
        t = mji*M[i];
        for (k=1;k<=size(lead_mod);k++){
          if (NF(t, lead_mod[k])==0){
            t = 0;
            break;
          }
          else{
            if(NF(lead_mod[k], t)==0){
              lead_mod = delete(lead_mod, k);
              k = k-1;
            }
          }
        }
        if(t != 0){
          lead_mod[size(lead_mod)+1] = t;
        }
      }
    }
  }
  return(lead_mod);
}


///////////////////////////////////////////////////////////////////////////////

proc lift_tree_(vector s, module M){
  vector g = phi_(s, M);
  vector T = remove_LOT_(g, M);
  vector L;
  vector ans = s; 
  int i;
  poly m;


  while (T != 0){
    L = lead(T);
    for(i=1; i<=size(M); i++){
      if(NF(L, leadmonom(M[i]))==0){
        m = leadmonomial_ext(L)/leadterm(M[i]);
        //check sign: 
        if (m*leadterm(M[i]) != leadterm(L)){
          m = -m;
        } 
        if (greater_than_(s, m*gen(i), M)){
          ans = ans - lift_subtree_(m*gen(i),M);
          break;
        }
      }
    }
    T = T - L;
  }
  return(ans);
}


///////////////////////////////////////////////////////////////////////////////

proc lift_subtree_(vector s, module M){
  vector g = phi_(s, M);
  g = g - lead(g);
  vector T = remove_LOT_(g, M);
  vector ans = s;
  poly m;
  int i;
  vector L;

  while (T != 0){
    if (leadexp(T)[nvars(basering)+1] > 15){
    }
    L = lead(T);
    for(i=1; i<=size(M); i++){
      if(NF(L, leadmonom(M[i]))==0){
        m = leadmonomial_ext(L)/leadmonomial_ext(M[i]); //TODO check sign!

        //check sign: 
        if (m*leadterm(M[i]) != leadterm(L)){
          m = -m;
        } 
        ans = ans - lift_subtree_(m*gen(i),M);
        break;
      }
    }
    T = T - L;
  }
  return(ans);
}


///////////////////////////////////////////////////////////////////////////////

//used in lift_tree_ and lift_subtree_
//computes the image of an element of lead_syz(m) in m

proc phi_(vector s, module m){
  int n = nvars(basering);
  int i = leadexp(s)[n+1];
  //s is a term
  poly t = leadterm(s);
  return(t*m[i]);
}


///////////////////////////////////////////////////////////////////////////////

//removes lower order terms from a vector with respect to a module in std form

//used in lift_tree_ and lift_subtree_
proc remove_LOT_(vector g, module m){
  vector L;
  int i;
  vector LOT;
  while(g != 0){
    for(i=1; i<=size(m); i++){
      L = lead(g);
      if(NF(L, leadmonom(m[i])) == 0){
        LOT = LOT+L;
        break;
      }
    }
    g = g - L;
  }
  return(LOT);
}


///////////////////////////////////////////////////////////////////////////////

// This procedure is implemented as a substitute for the schreyer ordering check in lift_tree

proc greater_than_(vector s, vector v, module M){
  int n = nvars(basering);
  int i = leadexp(s)[n+1];
  int j = leadexp(v)[n+1];
  poly mi = leadterm(s);
  poly mj = leadterm(v);
  if (lead(mi*M[i]) > lead(mj*M[j])){
    return(1);
  }
  else{
    if(lead(mi*M[i]) == lead(mj*M[j]) && i>j){
      return(1);
    }
    return(0);
  }
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
//NOTE: in the following code, there is no quotient ring computation. 
//
//now for exterior algebra 
//lifting the module from the quotient ring to the ncalg
proc add_ideal_gens_(module m){
  int n = nvars(basering);
  int i,j;
  for (i = 1; i<= n; i++){
    for (j = 1; j<= rank(m); j++){
      m[size(m)+1] = var(i)^2 * gen(j);
    }
  }
  return(m);
}


proc ext_elimination_(module m, module syz_mod){
  //note m is NOT lifted.
  int r = size(m);
  int n = nvars(basering);
  module ans_mod;
  
  matrix needed_mat = submat(matrix(syz_mod), 1..r, 1..size(syz_mod));
  ans_mod = module(needed_mat);
  int i,j,k;

  for(i=1;i<=size(ans_mod);i++){
    for(j=1;j<=nrows(matrix(ans_mod[i]));j++){
      for(k=1;k<=n;k++){
        if ((NF(ans_mod[i][j], var(k)^2) == 0) && ans_mod[i][j] != 0){
          ans_mod[i] = ans_mod[i] - ans_mod[i][j]*gen(j);
          break;
        }
      }
    }
    if(ans_mod[i] == 0){
        ans_mod = delete(ans_mod, i);
        i = i-1;
    }
  }
  return(ans_mod);
}


///////////////////////////////////////////////////////////////////////////////

//THIS IS THE MAIN USER CALLABLE PROCEDURE. WHAT RING SHOULD BE THE BASERING? 
proc schrey_syz(module m)
"USAGE:   schrey_syz(m); m a module over a commutative ring 
and the generators of m are 0 modulo var(i)^2 for all i.
RETURN:   module
PURPOSE:  computes the syzygy module of a module m over the exterior algebra. 
THEORY:   TODO
SEE ALSO: -
"
{
  int i,j;

  //create ring
  ring r = basering;
  int N = nvars(r);
  ring R = create_ring(ring_list(basering)[1], ringlist(basering)[2], "("+ordstr(basering)+")", "no_minpoly");
  matrix E = UpOneMatrix(N);
  E = -1*(E);
  def RR = nc_algebra(E,0); setring RR;
  
  //imap m to new ring
  module M = imap(r, m);

  module lift_m = add_ideal_gens_(M);
  module syz_mod = schreyers_syz_(lift_m);
  module ans_mod_ = ext_elimination_(M,syz_mod);

  //setring original ring
  setring r;

  //fetch ans_mod
  module ans_mod = imap(RR,ans_mod_);

  return(ans_mod);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = (0,q),(x,y,z),dp;
  vector f1 = [x,y,0,z,0,0];
  vector f2 = [0,x,y,0,z,0];
  vector f3 = [0,0,0,x,y,z];
  vector f4 = [0,0,xy,0,xz,0];
  vector f5 = [0,0,0,0,xy,xz];
  vector f6 = [0,0,0,0,0,xyz];
  module m = f1,f2,f3,f4,f5,f6;
  schrey_syz(m);
}

///////////////////////////////////////////////////////////////////////////////

//assume m is a module over the correct ring.
proc sres_(module m, int p)
{
  int i,j; 
  list res_list, lead_terms_list;
  lead_terms_list[1] = m;
  
  res_list[1] = m;
  for (i = 1; i<p; i++){
    print(res_list);
    res_list[i+1] = total_syz_alg(res_list[i], lead_terms_list);
    lead_terms_list[i+1] = lead(res_list[i+1]);
  }
  resolution ans_res = res_list;
  //can't return something in a different ring!!! 
  return(ans_res);
}

///////////////////////////////////////////////////////////////////////////////

proc total_syz_alg(module mod_, list L)
{
  module lift_m = add_ideal_gens_(mod_);
  L[size(L)] = lead(lift_m);
  module syz_mod = schreyers_syz_with_order(lift_m, L);

  module ans_mod = ext_elimination_(mod_,syz_mod);
  L[size(L)] = lead(mod_);
  //we are not sorting here!
  int i,j;
  for (i = 1; i<size(ans_mod); i++){
    for (j = i+1; j<=size(ans_mod); j++){
      if (ans_mod[i] == ans_mod[j]){
        ans_mod = delete(ans_mod,j);
        j--;
      }
    }
  }
  return(ans_mod);
}

///////////////////////////////////////////////////////////////////////////////

proc schreyers_syz_with_order(module m, list L)
{
  module lead_mod = lead_syz_(m);
  module ans;
  vector s;
  int i,j;
  for (i=1;i<=size(lead_mod); i++){
    s = lift_tree_with_order(lead_mod[i], m, L);
    ans[size(ans)+1] = s;
  }
  return(ans);
}

///////////////////////////////////////////////////////////////////////////////

proc lift_tree_with_order(vector s, module M, list LL){
  vector g = phi_(s, M);
  vector T = remove_LOT_(g, M);
  vector L;
  vector ans = s; 
  int i;
  poly m;
  
  ideal im, iF_, imif, iL;
  while (T != 0){
    L = lead(T);
    for(i=1; i<=size(M); i++){
      if(NF(L, leadmonom(M[i]))==0){
        m = leadmonomial_ext(L)/leadterm(M[i]); 
        
        //check sign: 
        if (m*leadterm(M[i])!= leadterm(L)){
          m = -m;
        } 
        //schreyer order algorithm should be called here
        if (gr_than_for_res(s,m*gen(i),LL)){
          ans = ans - lift_subtree_(m*gen(i),M);
          break;
        }
      }
    }
    T = T - L;
  }
  return(ans);
}

///////////////////////////////////////////////////////////////////////////////

proc gr_than_for_res(vector s, vector v, list L){
  if (size(L) == 1){
    return(greater_than_(s,v,L[1]));
  }
  int n = nvars(basering);
  poly m1 = leadterm(s); poly m2 = leadterm(v);
  int e1 = leadexp(s)[n+1]; int e2 = leadexp(v)[n+1];
  if(e1 == e2){
    return(m1>m2);
  }
  s = m1*L[size(L)][e1]; v = m2*L[size(L)][e2];
  if (s == v || s == -v){
    if(e1 > e2){
      return(1);
    }
    else{
      return(0);
    }
  }
  L = delete(L, size(L));
  return(gr_than_for_res(s,v,L));
}


///////////////////////////////////////////////////////////////////////////
/*enter a module m over the symmetric algebra
and compute the schreyer free resolution over the exterior algebra
fetch it back to the symmetric algebra and minimise*/

proc minimal_free_resolution(module m, int p){
  //first we build our required non-commutative ring.
  ring r = basering;
  int i;
  int N = nvars(basering);
  ring R = create_ring(ring_list(basering)[1], ringlist(basering)[2], "("+ordstr(basering)+")", "no_minpoly");
  intmat E = UpOneMatrix(N);
  E = -1*(E);
  def RR = nc_algebra(E,0); setring RR;

  //now we fetch the given module.
  module M = imap(r, m);

  //create the non-minimal resolution over the non-commutative ring.
  resolution res_ = sres_(M,p);
  int s = size(res_);

  //create the quotient ring over the symmetric algebra.
  ideal Q;
  for (i = 1; i<=N; i++){
    Q[i] = var(i)^2;
  }
  qring @r = Q;


  //fetch the resolution to the quotient ring over the symmetric algebra.
  
  list ans_L;
  for (i=1; i<=s; i++){
    setring RR;
    module temp_mod = res_[i];
    setring @r;
    ans_L[i] = fetch(RR, temp_mod);
  }

  //minimise the resolution over the quotient algebra.
  resolution quo_res = ans_L;
  quo_res = minres(quo_res);

  //return the minimised resolution over the symmetric algebra.
  list ans_L;
  for (i=1; i<=s; i++){
    setring @r;
    module temp_mod = quo_res[i];
    setring r;
    ans_L[i] = fetch(@r, temp_mod);
  }
  resolution ans_res = ans_L;
  return(ans_res);
}